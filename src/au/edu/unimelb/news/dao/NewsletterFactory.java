/* Generated by DaoGen version 0.1
 *
 * DO NOT EDIT THIS FILE. This file was automatically
 * generated, any changes made to this fill will be
 * lost if the file is re-generated.
 */
package au.edu.unimelb.news.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import javax.sql.DataSource;
import java.util.List;
import java.util.ArrayList;
import java.io.IOException;
import java.util.Date;

public class NewsletterFactory {

    private DataSource dataSource=null;

    public NewsletterFactory(DataSource dataSource) {
        this.dataSource = dataSource;
    }
    /**
     * Setup is called during factory initialization to 
     * allow any initialization to be done before this 
     * factory object is used.
     */
    public void setup() throws IOException {

        //Create the database table if it does not exist.
        Connection c=null;
        PreparedStatement s=null;
		try {
			c=dataSource.getConnection();
			s=c.prepareStatement(
				"create table if not exists newsletter (" +
				"id bigint auto_increment primary key,"+
                "publication_id bigint,"+
                "name varchar(250),"+
                "status varchar(100),"+
                "version bigint,"+
                "published boolean,"+
                "deleted boolean,"+
                "archived boolean,"+
                "last_update timestamp,"+
                "last_update_person_id bigint,"+
                "start_date timestamp,"+
                "end_date timestamp"+
				")DEFAULT CHARSET=utf8 ENGINE=innodb");
            s.execute();
            s.close();
            s=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(!e.toString().contains("ORA-00955")) {
                if(c!=null) { try { c.close(); } catch(Exception f){} }
                throw new IOException(e.toString());
            }
        }

        if(c!=null) { try { c.close(); } catch(Exception f){} }
    }

    /**
     * Post-setup is called when the DAO layer has completed 
     * initalisation of all DAO objects. 
     */
    public void postSetup() throws IOException {

    }

    /**
     * Retrieve an object from the <i>Newsletter</i> data source. 
     */
    public Newsletter get(long id) throws IOException {
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id,publication_id,name,status,version,published,deleted,archived,last_update,last_update_person_id,start_date,end_date "+
                "from newsletter " +
                "where id=?");
            s.setLong(1,id);
            results=s.executeQuery();
            if(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getTimestamp(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getTimestamp(11));
                item.setEndDate(results.getTimestamp(12));
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return item;
    }

    /**
     * Retrieve a list of objects from the <i>Newsletter</i>
     * data source. 
     */
    public List<Newsletter> getAll(long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            results=s.executeQuery();
            while(results.next()) {
                Newsletter item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getTimestamp(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getTimestamp(11));
                item.setEndDate(results.getTimestamp(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Permanently remove an object from the <i>Newsletter</i>
     * data source. 
     */
    public void delete(long id) throws IOException {
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter "+
                "where id=?");
            s.setLong(1,id);
            s.execute();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

    }

    /**
     * Permanently remove all objects from the <i>Newsletter</i>
     * data source. 
     */
    public void deleteAll() throws IOException {
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement("delete from newsletter"); 
            s.execute();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

    }

    /**
     * Add a new <i>Newsletter</i> object to the data source. 
     */
    public Newsletter insert(Newsletter item) throws IOException {
        Connection c=null;
        PreparedStatement s=null;

        try {
            c=dataSource.getConnection();

			s=c.prepareStatement(
				"insert into newsletter ("+
					((item.getId()>0)?"id, ":"")+
                    "publication_id, "+
                    "name, "+
                    "status, "+
                    "version, "+
                    "published, "+
                    "deleted, "+
                    "archived, "+
                    "last_update, "+
                    "last_update_person_id, "+
                    "start_date, "+
                    "end_date) "+
                "values("+(item.getId()>0?"?,":"")+"?,?,?,?,?,?,?,?,?,?,?)");
			if(item.getId()>0) {
			s.setLong(1,item.getId());
            s.setLong(2,item.getPublicationId());
            s.setString(3,item.getName());
            s.setString(4,item.getStatus());
            s.setLong(5,item.getVersion());
            s.setBoolean(6,item.isPublished());
            s.setBoolean(7,item.isDeleted());
            s.setBoolean(8,item.isArchived());
            s.setTimestamp(9,new java.sql.Timestamp(item.getLastUpdate().getTime()));
            s.setLong(10,item.getLastUpdatePersonId());
            s.setTimestamp(11,new java.sql.Timestamp(item.getStartDate().getTime()));
            s.setTimestamp(12,new java.sql.Timestamp(item.getEndDate().getTime()));
			} else {
            s.setLong(1,item.getPublicationId());
            s.setString(2,item.getName());
            s.setString(3,item.getStatus());
            s.setLong(4,item.getVersion());
            s.setBoolean(5,item.isPublished());
            s.setBoolean(6,item.isDeleted());
            s.setBoolean(7,item.isArchived());
            s.setTimestamp(8,new java.sql.Timestamp(item.getLastUpdate().getTime()));
            s.setLong(9,item.getLastUpdatePersonId());
            s.setTimestamp(10,new java.sql.Timestamp(item.getStartDate().getTime()));
            s.setTimestamp(11,new java.sql.Timestamp(item.getEndDate().getTime()));
			}
            s.execute();
            // Discover the unique id allocated to the new record
            ResultSet r = s.getGeneratedKeys();
            if (r.next()) {
            	item.setId(r.getInt(1));
            }
            r.close();
            r=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            System.err.println("Problem duing inserting into table newsletter. "+
                "publication_id="+item.getPublicationId()+", "+ 
                "name="+item.getName()+", "+ 
                "status="+item.getStatus()+", "+ 
                "version="+item.getVersion()+", "+ 
                "published="+item.isPublished()+", "+ 
                "deleted="+item.isDeleted()+", "+ 
                "archived="+item.isArchived()+", "+ 
                "last_update="+item.getLastUpdate()+", "+ 
                "last_update_person_id="+item.getLastUpdatePersonId()+", "+ 
                "start_date="+item.getStartDate()+", "+ 
                "end_date="+item.getEndDate()+", "+ 
        "");
            throw new IOException(e.toString());
        }

        return item;
    }

    /**
     * Update an object of type <i>Newsletter</i> the 
     * data source. 
     */
    public void update(Newsletter item) throws IOException {
        Connection c=null;
        PreparedStatement s=null;

        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "update newsletter set publication_id=?, name=?, status=?, version=?, published=?, deleted=?, archived=?, last_update=?, last_update_person_id=?, start_date=?, end_date=? "+
                "where id=?");
            s.setLong(1,item.getPublicationId());
            s.setString(2,item.getName());
            s.setString(3,item.getStatus());
            s.setLong(4,item.getVersion());
            s.setBoolean(5,item.isPublished());
            s.setBoolean(6,item.isDeleted());
            s.setBoolean(7,item.isArchived());
            s.setTimestamp(8,new java.sql.Timestamp(item.getLastUpdate().getTime()));
            s.setLong(9,item.getLastUpdatePersonId());
            s.setTimestamp(10,new java.sql.Timestamp(item.getStartDate().getTime()));
            s.setTimestamp(11,new java.sql.Timestamp(item.getEndDate().getTime()));
            s.setLong(12,item.getId());
            s.execute();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

    }

    /**
     * Count the number of objects from the <i>Newsletter</i>
     * data source. 
     */
    public long countAll() throws IOException {
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        long count=0;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(1) "+
                "from newsletter "
                );
            results=s.executeQuery();
            if(results.next())
                count=results.getLong(1);
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return count;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on publicationId. 
     *
     * @param publicationId Value to match on Publication Id.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByPublicationId(Long publicationId,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where publication_id=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,publicationId);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Publication Id. 
     *
     * @param publicationId Value to match on Publication Id.
     */
    public long countByPublicationId(Long publicationId) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where publication_id=? " +
                "");
            s.setLong(1,publicationId);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Publication Id. 
     *
     * @param PublicationId Value to match on Publication Id.
     */
    public long deleteByPublicationId(Long publicationId) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where publication_id=? " +
                "");
            s.setLong(1,publicationId);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on status. 
     *
     * @param status Value to match on Status.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByStatus(String status,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where status=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,status);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Status. 
     *
     * @param status Value to match on Status.
     */
    public long countByStatus(String status) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where status=? " +
                "");
            s.setString(1,status);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Status. 
     *
     * @param Status Value to match on Status.
     */
    public long deleteByStatus(String status) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where status=? " +
                "");
            s.setString(1,status);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on version. 
     *
     * @param version Value to match on Version.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByVersion(Long version,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where version=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,version);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Version. 
     *
     * @param version Value to match on Version.
     */
    public long countByVersion(Long version) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where version=? " +
                "");
            s.setLong(1,version);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Version. 
     *
     * @param Version Value to match on Version.
     */
    public long deleteByVersion(Long version) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where version=? " +
                "");
            s.setLong(1,version);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on published. 
     *
     * @param published Value to match on Published.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByPublished(Boolean published,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where published=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setBoolean(1,published);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Published. 
     *
     * @param published Value to match on Published.
     */
    public long countByPublished(Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where published=? " +
                "");
            s.setBoolean(1,published);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Published. 
     *
     * @param Published Value to match on Published.
     */
    public long deleteByPublished(Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where published=? " +
                "");
            s.setBoolean(1,published);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on archived. 
     *
     * @param archived Value to match on Archived.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByArchived(Boolean archived,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where archived=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setBoolean(1,archived);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Archived. 
     *
     * @param archived Value to match on Archived.
     */
    public long countByArchived(Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where archived=? " +
                "");
            s.setBoolean(1,archived);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Archived. 
     *
     * @param Archived Value to match on Archived.
     */
    public long deleteByArchived(Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where archived=? " +
                "");
            s.setBoolean(1,archived);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on lastUpdate. 
     *
     * @param lastUpdate Value to match on Last Update.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByLastUpdate(Date lastUpdate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where last_update=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Last Update. 
     *
     * @param lastUpdate Value to match on Last Update.
     */
    public long countByLastUpdate(Date lastUpdate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where last_update=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Last Update. 
     *
     * @param LastUpdate Value to match on Last Update.
     */
    public long deleteByLastUpdate(Date lastUpdate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where last_update=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on lastUpdatePersonId. 
     *
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByLastUpdatePersonId(Long lastUpdatePersonId,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where last_update_person_id=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,lastUpdatePersonId);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Last Update Person Id. 
     *
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     */
    public long countByLastUpdatePersonId(Long lastUpdatePersonId) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where last_update_person_id=? " +
                "");
            s.setLong(1,lastUpdatePersonId);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Last Update Person Id. 
     *
     * @param LastUpdatePersonId Value to match on Last Update Person Id.
     */
    public long deleteByLastUpdatePersonId(Long lastUpdatePersonId) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where last_update_person_id=? " +
                "");
            s.setLong(1,lastUpdatePersonId);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on startDate. 
     *
     * @param startDate Value to match on Start Date.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByStartDate(Date startDate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where start_date=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setTimestamp(1,new java.sql.Timestamp(startDate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Start Date. 
     *
     * @param startDate Value to match on Start Date.
     */
    public long countByStartDate(Date startDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where start_date=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(startDate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Start Date. 
     *
     * @param StartDate Value to match on Start Date.
     */
    public long deleteByStartDate(Date startDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where start_date=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(startDate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on endDate. 
     *
     * @param endDate Value to match on End Date.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByEndDate(Date endDate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where end_date=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setTimestamp(1,new java.sql.Timestamp(endDate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on End Date. 
     *
     * @param endDate Value to match on End Date.
     */
    public long countByEndDate(Date endDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where end_date=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(endDate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on End Date. 
     *
     * @param EndDate Value to match on End Date.
     */
    public long deleteByEndDate(Date endDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where end_date=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(endDate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on name publicationId. 
     *
     * @param name Value to match on Name.
     * @param publicationId Value to match on Publication Id.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByNamePublicationId(String name, Long publicationId,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where name=? and publication_id=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,name);
            s.setLong(2,publicationId);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Name Publication Id. 
     *
     * @param name Value to match on Name.
     * @param publicationId Value to match on Publication Id.
     */
    public long countByNamePublicationId(String name, Long publicationId) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where name=? and publication_id=? " +
                "");
            s.setString(1,name);
            s.setLong(2,publicationId);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Name Publication Id. 
     *
     * @param Name Value to match on Name.
     * @param PublicationId Value to match on Publication Id.
     */
    public long deleteByNamePublicationId(String name, Long publicationId) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where name=? and publication_id=? " +
                "");
            s.setString(1,name);
            s.setLong(2,publicationId);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on status publicationId. 
     *
     * @param status Value to match on Status.
     * @param publicationId Value to match on Publication Id.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByStatusPublicationId(String status, Long publicationId,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where status=? and publication_id=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,status);
            s.setLong(2,publicationId);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Status Publication Id. 
     *
     * @param status Value to match on Status.
     * @param publicationId Value to match on Publication Id.
     */
    public long countByStatusPublicationId(String status, Long publicationId) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where status=? and publication_id=? " +
                "");
            s.setString(1,status);
            s.setLong(2,publicationId);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Status Publication Id. 
     *
     * @param Status Value to match on Status.
     * @param PublicationId Value to match on Publication Id.
     */
    public long deleteByStatusPublicationId(String status, Long publicationId) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where status=? and publication_id=? " +
                "");
            s.setString(1,status);
            s.setLong(2,publicationId);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on publicationId version. 
     *
     * @param publicationId Value to match on Publication Id.
     * @param version Value to match on Version.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByPublicationIdVersion(Long publicationId, Long version,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where publication_id=? and version=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,publicationId);
            s.setLong(2,version);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Publication Id Version. 
     *
     * @param publicationId Value to match on Publication Id.
     * @param version Value to match on Version.
     */
    public long countByPublicationIdVersion(Long publicationId, Long version) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where publication_id=? and version=? " +
                "");
            s.setLong(1,publicationId);
            s.setLong(2,version);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Publication Id Version. 
     *
     * @param PublicationId Value to match on Publication Id.
     * @param Version Value to match on Version.
     */
    public long deleteByPublicationIdVersion(Long publicationId, Long version) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where publication_id=? and version=? " +
                "");
            s.setLong(1,publicationId);
            s.setLong(2,version);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on publicationId published. 
     *
     * @param publicationId Value to match on Publication Id.
     * @param published Value to match on Published.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByPublicationIdPublished(Long publicationId, Boolean published,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where publication_id=? and published=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,publicationId);
            s.setBoolean(2,published);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Publication Id Published. 
     *
     * @param publicationId Value to match on Publication Id.
     * @param published Value to match on Published.
     */
    public long countByPublicationIdPublished(Long publicationId, Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where publication_id=? and published=? " +
                "");
            s.setLong(1,publicationId);
            s.setBoolean(2,published);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Publication Id Published. 
     *
     * @param PublicationId Value to match on Publication Id.
     * @param Published Value to match on Published.
     */
    public long deleteByPublicationIdPublished(Long publicationId, Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where publication_id=? and published=? " +
                "");
            s.setLong(1,publicationId);
            s.setBoolean(2,published);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on publicationId deleted. 
     *
     * @param publicationId Value to match on Publication Id.
     * @param deleted Value to match on Deleted.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByPublicationIdDeleted(Long publicationId, Boolean deleted,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where publication_id=? and deleted=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,publicationId);
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Publication Id Deleted. 
     *
     * @param publicationId Value to match on Publication Id.
     * @param deleted Value to match on Deleted.
     */
    public long countByPublicationIdDeleted(Long publicationId, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where publication_id=? and deleted=? " +
                "");
            s.setLong(1,publicationId);
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Publication Id Deleted. 
     *
     * @param PublicationId Value to match on Publication Id.
     * @param Deleted Value to match on Deleted.
     */
    public long deleteByPublicationIdDeleted(Long publicationId, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where publication_id=? and deleted=? " +
                "");
            s.setLong(1,publicationId);
            s.setBoolean(2,deleted);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on publicationId archived. 
     *
     * @param publicationId Value to match on Publication Id.
     * @param archived Value to match on Archived.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByPublicationIdArchived(Long publicationId, Boolean archived,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where publication_id=? and archived=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,publicationId);
            s.setBoolean(2,archived);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Publication Id Archived. 
     *
     * @param publicationId Value to match on Publication Id.
     * @param archived Value to match on Archived.
     */
    public long countByPublicationIdArchived(Long publicationId, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where publication_id=? and archived=? " +
                "");
            s.setLong(1,publicationId);
            s.setBoolean(2,archived);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Publication Id Archived. 
     *
     * @param PublicationId Value to match on Publication Id.
     * @param Archived Value to match on Archived.
     */
    public long deleteByPublicationIdArchived(Long publicationId, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where publication_id=? and archived=? " +
                "");
            s.setLong(1,publicationId);
            s.setBoolean(2,archived);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on publicationId lastUpdate. 
     *
     * @param publicationId Value to match on Publication Id.
     * @param lastUpdate Value to match on Last Update.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByPublicationIdLastUpdate(Long publicationId, Date lastUpdate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where publication_id=? and last_update=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,publicationId);
            s.setTimestamp(2,new java.sql.Timestamp(lastUpdate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Publication Id Last Update. 
     *
     * @param publicationId Value to match on Publication Id.
     * @param lastUpdate Value to match on Last Update.
     */
    public long countByPublicationIdLastUpdate(Long publicationId, Date lastUpdate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where publication_id=? and last_update=? " +
                "");
            s.setLong(1,publicationId);
            s.setTimestamp(2,new java.sql.Timestamp(lastUpdate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Publication Id Last Update. 
     *
     * @param PublicationId Value to match on Publication Id.
     * @param LastUpdate Value to match on Last Update.
     */
    public long deleteByPublicationIdLastUpdate(Long publicationId, Date lastUpdate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where publication_id=? and last_update=? " +
                "");
            s.setLong(1,publicationId);
            s.setTimestamp(2,new java.sql.Timestamp(lastUpdate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on publicationId lastUpdatePersonId. 
     *
     * @param publicationId Value to match on Publication Id.
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByPublicationIdLastUpdatePersonId(Long publicationId, Long lastUpdatePersonId,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where publication_id=? and last_update_person_id=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,publicationId);
            s.setLong(2,lastUpdatePersonId);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Publication Id Last Update Person Id. 
     *
     * @param publicationId Value to match on Publication Id.
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     */
    public long countByPublicationIdLastUpdatePersonId(Long publicationId, Long lastUpdatePersonId) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where publication_id=? and last_update_person_id=? " +
                "");
            s.setLong(1,publicationId);
            s.setLong(2,lastUpdatePersonId);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Publication Id Last Update Person Id. 
     *
     * @param PublicationId Value to match on Publication Id.
     * @param LastUpdatePersonId Value to match on Last Update Person Id.
     */
    public long deleteByPublicationIdLastUpdatePersonId(Long publicationId, Long lastUpdatePersonId) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where publication_id=? and last_update_person_id=? " +
                "");
            s.setLong(1,publicationId);
            s.setLong(2,lastUpdatePersonId);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on publicationId startDate. 
     *
     * @param publicationId Value to match on Publication Id.
     * @param startDate Value to match on Start Date.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByPublicationIdStartDate(Long publicationId, Date startDate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where publication_id=? and start_date=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,publicationId);
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Publication Id Start Date. 
     *
     * @param publicationId Value to match on Publication Id.
     * @param startDate Value to match on Start Date.
     */
    public long countByPublicationIdStartDate(Long publicationId, Date startDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where publication_id=? and start_date=? " +
                "");
            s.setLong(1,publicationId);
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Publication Id Start Date. 
     *
     * @param PublicationId Value to match on Publication Id.
     * @param StartDate Value to match on Start Date.
     */
    public long deleteByPublicationIdStartDate(Long publicationId, Date startDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where publication_id=? and start_date=? " +
                "");
            s.setLong(1,publicationId);
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on publicationId endDate. 
     *
     * @param publicationId Value to match on Publication Id.
     * @param endDate Value to match on End Date.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByPublicationIdEndDate(Long publicationId, Date endDate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where publication_id=? and end_date=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,publicationId);
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Publication Id End Date. 
     *
     * @param publicationId Value to match on Publication Id.
     * @param endDate Value to match on End Date.
     */
    public long countByPublicationIdEndDate(Long publicationId, Date endDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where publication_id=? and end_date=? " +
                "");
            s.setLong(1,publicationId);
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Publication Id End Date. 
     *
     * @param PublicationId Value to match on Publication Id.
     * @param EndDate Value to match on End Date.
     */
    public long deleteByPublicationIdEndDate(Long publicationId, Date endDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where publication_id=? and end_date=? " +
                "");
            s.setLong(1,publicationId);
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on name status. 
     *
     * @param name Value to match on Name.
     * @param status Value to match on Status.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByNameStatus(String name, String status,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where name=? and status=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,name);
            s.setString(2,status);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Name Status. 
     *
     * @param name Value to match on Name.
     * @param status Value to match on Status.
     */
    public long countByNameStatus(String name, String status) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where name=? and status=? " +
                "");
            s.setString(1,name);
            s.setString(2,status);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Name Status. 
     *
     * @param Name Value to match on Name.
     * @param Status Value to match on Status.
     */
    public long deleteByNameStatus(String name, String status) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where name=? and status=? " +
                "");
            s.setString(1,name);
            s.setString(2,status);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on name version. 
     *
     * @param name Value to match on Name.
     * @param version Value to match on Version.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByNameVersion(String name, Long version,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where name=? and version=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,name);
            s.setLong(2,version);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Name Version. 
     *
     * @param name Value to match on Name.
     * @param version Value to match on Version.
     */
    public long countByNameVersion(String name, Long version) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where name=? and version=? " +
                "");
            s.setString(1,name);
            s.setLong(2,version);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Name Version. 
     *
     * @param Name Value to match on Name.
     * @param Version Value to match on Version.
     */
    public long deleteByNameVersion(String name, Long version) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where name=? and version=? " +
                "");
            s.setString(1,name);
            s.setLong(2,version);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on name published. 
     *
     * @param name Value to match on Name.
     * @param published Value to match on Published.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByNamePublished(String name, Boolean published,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where name=? and published=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,name);
            s.setBoolean(2,published);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Name Published. 
     *
     * @param name Value to match on Name.
     * @param published Value to match on Published.
     */
    public long countByNamePublished(String name, Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where name=? and published=? " +
                "");
            s.setString(1,name);
            s.setBoolean(2,published);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Name Published. 
     *
     * @param Name Value to match on Name.
     * @param Published Value to match on Published.
     */
    public long deleteByNamePublished(String name, Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where name=? and published=? " +
                "");
            s.setString(1,name);
            s.setBoolean(2,published);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on name deleted. 
     *
     * @param name Value to match on Name.
     * @param deleted Value to match on Deleted.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByNameDeleted(String name, Boolean deleted,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where name=? and deleted=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,name);
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Name Deleted. 
     *
     * @param name Value to match on Name.
     * @param deleted Value to match on Deleted.
     */
    public long countByNameDeleted(String name, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where name=? and deleted=? " +
                "");
            s.setString(1,name);
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Name Deleted. 
     *
     * @param Name Value to match on Name.
     * @param Deleted Value to match on Deleted.
     */
    public long deleteByNameDeleted(String name, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where name=? and deleted=? " +
                "");
            s.setString(1,name);
            s.setBoolean(2,deleted);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on name archived. 
     *
     * @param name Value to match on Name.
     * @param archived Value to match on Archived.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByNameArchived(String name, Boolean archived,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where name=? and archived=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,name);
            s.setBoolean(2,archived);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Name Archived. 
     *
     * @param name Value to match on Name.
     * @param archived Value to match on Archived.
     */
    public long countByNameArchived(String name, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where name=? and archived=? " +
                "");
            s.setString(1,name);
            s.setBoolean(2,archived);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Name Archived. 
     *
     * @param Name Value to match on Name.
     * @param Archived Value to match on Archived.
     */
    public long deleteByNameArchived(String name, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where name=? and archived=? " +
                "");
            s.setString(1,name);
            s.setBoolean(2,archived);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on name lastUpdate. 
     *
     * @param name Value to match on Name.
     * @param lastUpdate Value to match on Last Update.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByNameLastUpdate(String name, Date lastUpdate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where name=? and last_update=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,name);
            s.setTimestamp(2,new java.sql.Timestamp(lastUpdate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Name Last Update. 
     *
     * @param name Value to match on Name.
     * @param lastUpdate Value to match on Last Update.
     */
    public long countByNameLastUpdate(String name, Date lastUpdate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where name=? and last_update=? " +
                "");
            s.setString(1,name);
            s.setTimestamp(2,new java.sql.Timestamp(lastUpdate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Name Last Update. 
     *
     * @param Name Value to match on Name.
     * @param LastUpdate Value to match on Last Update.
     */
    public long deleteByNameLastUpdate(String name, Date lastUpdate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where name=? and last_update=? " +
                "");
            s.setString(1,name);
            s.setTimestamp(2,new java.sql.Timestamp(lastUpdate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on name lastUpdatePersonId. 
     *
     * @param name Value to match on Name.
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByNameLastUpdatePersonId(String name, Long lastUpdatePersonId,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where name=? and last_update_person_id=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,name);
            s.setLong(2,lastUpdatePersonId);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Name Last Update Person Id. 
     *
     * @param name Value to match on Name.
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     */
    public long countByNameLastUpdatePersonId(String name, Long lastUpdatePersonId) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where name=? and last_update_person_id=? " +
                "");
            s.setString(1,name);
            s.setLong(2,lastUpdatePersonId);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Name Last Update Person Id. 
     *
     * @param Name Value to match on Name.
     * @param LastUpdatePersonId Value to match on Last Update Person Id.
     */
    public long deleteByNameLastUpdatePersonId(String name, Long lastUpdatePersonId) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where name=? and last_update_person_id=? " +
                "");
            s.setString(1,name);
            s.setLong(2,lastUpdatePersonId);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on name startDate. 
     *
     * @param name Value to match on Name.
     * @param startDate Value to match on Start Date.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByNameStartDate(String name, Date startDate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where name=? and start_date=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,name);
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Name Start Date. 
     *
     * @param name Value to match on Name.
     * @param startDate Value to match on Start Date.
     */
    public long countByNameStartDate(String name, Date startDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where name=? and start_date=? " +
                "");
            s.setString(1,name);
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Name Start Date. 
     *
     * @param Name Value to match on Name.
     * @param StartDate Value to match on Start Date.
     */
    public long deleteByNameStartDate(String name, Date startDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where name=? and start_date=? " +
                "");
            s.setString(1,name);
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on name endDate. 
     *
     * @param name Value to match on Name.
     * @param endDate Value to match on End Date.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByNameEndDate(String name, Date endDate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where name=? and end_date=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,name);
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Name End Date. 
     *
     * @param name Value to match on Name.
     * @param endDate Value to match on End Date.
     */
    public long countByNameEndDate(String name, Date endDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where name=? and end_date=? " +
                "");
            s.setString(1,name);
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Name End Date. 
     *
     * @param Name Value to match on Name.
     * @param EndDate Value to match on End Date.
     */
    public long deleteByNameEndDate(String name, Date endDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where name=? and end_date=? " +
                "");
            s.setString(1,name);
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on status version. 
     *
     * @param status Value to match on Status.
     * @param version Value to match on Version.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByStatusVersion(String status, Long version,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where status=? and version=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,status);
            s.setLong(2,version);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Status Version. 
     *
     * @param status Value to match on Status.
     * @param version Value to match on Version.
     */
    public long countByStatusVersion(String status, Long version) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where status=? and version=? " +
                "");
            s.setString(1,status);
            s.setLong(2,version);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Status Version. 
     *
     * @param Status Value to match on Status.
     * @param Version Value to match on Version.
     */
    public long deleteByStatusVersion(String status, Long version) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where status=? and version=? " +
                "");
            s.setString(1,status);
            s.setLong(2,version);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on status published. 
     *
     * @param status Value to match on Status.
     * @param published Value to match on Published.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByStatusPublished(String status, Boolean published,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where status=? and published=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,status);
            s.setBoolean(2,published);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Status Published. 
     *
     * @param status Value to match on Status.
     * @param published Value to match on Published.
     */
    public long countByStatusPublished(String status, Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where status=? and published=? " +
                "");
            s.setString(1,status);
            s.setBoolean(2,published);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Status Published. 
     *
     * @param Status Value to match on Status.
     * @param Published Value to match on Published.
     */
    public long deleteByStatusPublished(String status, Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where status=? and published=? " +
                "");
            s.setString(1,status);
            s.setBoolean(2,published);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on status deleted. 
     *
     * @param status Value to match on Status.
     * @param deleted Value to match on Deleted.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByStatusDeleted(String status, Boolean deleted,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where status=? and deleted=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,status);
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Status Deleted. 
     *
     * @param status Value to match on Status.
     * @param deleted Value to match on Deleted.
     */
    public long countByStatusDeleted(String status, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where status=? and deleted=? " +
                "");
            s.setString(1,status);
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Status Deleted. 
     *
     * @param Status Value to match on Status.
     * @param Deleted Value to match on Deleted.
     */
    public long deleteByStatusDeleted(String status, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where status=? and deleted=? " +
                "");
            s.setString(1,status);
            s.setBoolean(2,deleted);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on status archived. 
     *
     * @param status Value to match on Status.
     * @param archived Value to match on Archived.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByStatusArchived(String status, Boolean archived,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where status=? and archived=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,status);
            s.setBoolean(2,archived);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Status Archived. 
     *
     * @param status Value to match on Status.
     * @param archived Value to match on Archived.
     */
    public long countByStatusArchived(String status, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where status=? and archived=? " +
                "");
            s.setString(1,status);
            s.setBoolean(2,archived);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Status Archived. 
     *
     * @param Status Value to match on Status.
     * @param Archived Value to match on Archived.
     */
    public long deleteByStatusArchived(String status, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where status=? and archived=? " +
                "");
            s.setString(1,status);
            s.setBoolean(2,archived);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on status lastUpdate. 
     *
     * @param status Value to match on Status.
     * @param lastUpdate Value to match on Last Update.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByStatusLastUpdate(String status, Date lastUpdate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where status=? and last_update=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,status);
            s.setTimestamp(2,new java.sql.Timestamp(lastUpdate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Status Last Update. 
     *
     * @param status Value to match on Status.
     * @param lastUpdate Value to match on Last Update.
     */
    public long countByStatusLastUpdate(String status, Date lastUpdate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where status=? and last_update=? " +
                "");
            s.setString(1,status);
            s.setTimestamp(2,new java.sql.Timestamp(lastUpdate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Status Last Update. 
     *
     * @param Status Value to match on Status.
     * @param LastUpdate Value to match on Last Update.
     */
    public long deleteByStatusLastUpdate(String status, Date lastUpdate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where status=? and last_update=? " +
                "");
            s.setString(1,status);
            s.setTimestamp(2,new java.sql.Timestamp(lastUpdate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on status lastUpdatePersonId. 
     *
     * @param status Value to match on Status.
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByStatusLastUpdatePersonId(String status, Long lastUpdatePersonId,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where status=? and last_update_person_id=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,status);
            s.setLong(2,lastUpdatePersonId);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Status Last Update Person Id. 
     *
     * @param status Value to match on Status.
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     */
    public long countByStatusLastUpdatePersonId(String status, Long lastUpdatePersonId) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where status=? and last_update_person_id=? " +
                "");
            s.setString(1,status);
            s.setLong(2,lastUpdatePersonId);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Status Last Update Person Id. 
     *
     * @param Status Value to match on Status.
     * @param LastUpdatePersonId Value to match on Last Update Person Id.
     */
    public long deleteByStatusLastUpdatePersonId(String status, Long lastUpdatePersonId) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where status=? and last_update_person_id=? " +
                "");
            s.setString(1,status);
            s.setLong(2,lastUpdatePersonId);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on status startDate. 
     *
     * @param status Value to match on Status.
     * @param startDate Value to match on Start Date.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByStatusStartDate(String status, Date startDate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where status=? and start_date=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,status);
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Status Start Date. 
     *
     * @param status Value to match on Status.
     * @param startDate Value to match on Start Date.
     */
    public long countByStatusStartDate(String status, Date startDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where status=? and start_date=? " +
                "");
            s.setString(1,status);
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Status Start Date. 
     *
     * @param Status Value to match on Status.
     * @param StartDate Value to match on Start Date.
     */
    public long deleteByStatusStartDate(String status, Date startDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where status=? and start_date=? " +
                "");
            s.setString(1,status);
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on status endDate. 
     *
     * @param status Value to match on Status.
     * @param endDate Value to match on End Date.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByStatusEndDate(String status, Date endDate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where status=? and end_date=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,status);
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Status End Date. 
     *
     * @param status Value to match on Status.
     * @param endDate Value to match on End Date.
     */
    public long countByStatusEndDate(String status, Date endDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where status=? and end_date=? " +
                "");
            s.setString(1,status);
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Status End Date. 
     *
     * @param Status Value to match on Status.
     * @param EndDate Value to match on End Date.
     */
    public long deleteByStatusEndDate(String status, Date endDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where status=? and end_date=? " +
                "");
            s.setString(1,status);
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on version published. 
     *
     * @param version Value to match on Version.
     * @param published Value to match on Published.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByVersionPublished(Long version, Boolean published,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where version=? and published=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,version);
            s.setBoolean(2,published);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Version Published. 
     *
     * @param version Value to match on Version.
     * @param published Value to match on Published.
     */
    public long countByVersionPublished(Long version, Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where version=? and published=? " +
                "");
            s.setLong(1,version);
            s.setBoolean(2,published);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Version Published. 
     *
     * @param Version Value to match on Version.
     * @param Published Value to match on Published.
     */
    public long deleteByVersionPublished(Long version, Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where version=? and published=? " +
                "");
            s.setLong(1,version);
            s.setBoolean(2,published);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on version deleted. 
     *
     * @param version Value to match on Version.
     * @param deleted Value to match on Deleted.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByVersionDeleted(Long version, Boolean deleted,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where version=? and deleted=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,version);
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Version Deleted. 
     *
     * @param version Value to match on Version.
     * @param deleted Value to match on Deleted.
     */
    public long countByVersionDeleted(Long version, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where version=? and deleted=? " +
                "");
            s.setLong(1,version);
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Version Deleted. 
     *
     * @param Version Value to match on Version.
     * @param Deleted Value to match on Deleted.
     */
    public long deleteByVersionDeleted(Long version, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where version=? and deleted=? " +
                "");
            s.setLong(1,version);
            s.setBoolean(2,deleted);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on version archived. 
     *
     * @param version Value to match on Version.
     * @param archived Value to match on Archived.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByVersionArchived(Long version, Boolean archived,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where version=? and archived=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,version);
            s.setBoolean(2,archived);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Version Archived. 
     *
     * @param version Value to match on Version.
     * @param archived Value to match on Archived.
     */
    public long countByVersionArchived(Long version, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where version=? and archived=? " +
                "");
            s.setLong(1,version);
            s.setBoolean(2,archived);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Version Archived. 
     *
     * @param Version Value to match on Version.
     * @param Archived Value to match on Archived.
     */
    public long deleteByVersionArchived(Long version, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where version=? and archived=? " +
                "");
            s.setLong(1,version);
            s.setBoolean(2,archived);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on version lastUpdate. 
     *
     * @param version Value to match on Version.
     * @param lastUpdate Value to match on Last Update.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByVersionLastUpdate(Long version, Date lastUpdate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where version=? and last_update=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,version);
            s.setTimestamp(2,new java.sql.Timestamp(lastUpdate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Version Last Update. 
     *
     * @param version Value to match on Version.
     * @param lastUpdate Value to match on Last Update.
     */
    public long countByVersionLastUpdate(Long version, Date lastUpdate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where version=? and last_update=? " +
                "");
            s.setLong(1,version);
            s.setTimestamp(2,new java.sql.Timestamp(lastUpdate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Version Last Update. 
     *
     * @param Version Value to match on Version.
     * @param LastUpdate Value to match on Last Update.
     */
    public long deleteByVersionLastUpdate(Long version, Date lastUpdate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where version=? and last_update=? " +
                "");
            s.setLong(1,version);
            s.setTimestamp(2,new java.sql.Timestamp(lastUpdate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on version lastUpdatePersonId. 
     *
     * @param version Value to match on Version.
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByVersionLastUpdatePersonId(Long version, Long lastUpdatePersonId,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where version=? and last_update_person_id=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,version);
            s.setLong(2,lastUpdatePersonId);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Version Last Update Person Id. 
     *
     * @param version Value to match on Version.
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     */
    public long countByVersionLastUpdatePersonId(Long version, Long lastUpdatePersonId) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where version=? and last_update_person_id=? " +
                "");
            s.setLong(1,version);
            s.setLong(2,lastUpdatePersonId);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Version Last Update Person Id. 
     *
     * @param Version Value to match on Version.
     * @param LastUpdatePersonId Value to match on Last Update Person Id.
     */
    public long deleteByVersionLastUpdatePersonId(Long version, Long lastUpdatePersonId) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where version=? and last_update_person_id=? " +
                "");
            s.setLong(1,version);
            s.setLong(2,lastUpdatePersonId);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on version startDate. 
     *
     * @param version Value to match on Version.
     * @param startDate Value to match on Start Date.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByVersionStartDate(Long version, Date startDate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where version=? and start_date=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,version);
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Version Start Date. 
     *
     * @param version Value to match on Version.
     * @param startDate Value to match on Start Date.
     */
    public long countByVersionStartDate(Long version, Date startDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where version=? and start_date=? " +
                "");
            s.setLong(1,version);
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Version Start Date. 
     *
     * @param Version Value to match on Version.
     * @param StartDate Value to match on Start Date.
     */
    public long deleteByVersionStartDate(Long version, Date startDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where version=? and start_date=? " +
                "");
            s.setLong(1,version);
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on version endDate. 
     *
     * @param version Value to match on Version.
     * @param endDate Value to match on End Date.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByVersionEndDate(Long version, Date endDate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where version=? and end_date=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,version);
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Version End Date. 
     *
     * @param version Value to match on Version.
     * @param endDate Value to match on End Date.
     */
    public long countByVersionEndDate(Long version, Date endDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where version=? and end_date=? " +
                "");
            s.setLong(1,version);
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Version End Date. 
     *
     * @param Version Value to match on Version.
     * @param EndDate Value to match on End Date.
     */
    public long deleteByVersionEndDate(Long version, Date endDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where version=? and end_date=? " +
                "");
            s.setLong(1,version);
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on published deleted. 
     *
     * @param published Value to match on Published.
     * @param deleted Value to match on Deleted.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByPublishedDeleted(Boolean published, Boolean deleted,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where published=? and deleted=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setBoolean(1,published);
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Published Deleted. 
     *
     * @param published Value to match on Published.
     * @param deleted Value to match on Deleted.
     */
    public long countByPublishedDeleted(Boolean published, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where published=? and deleted=? " +
                "");
            s.setBoolean(1,published);
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Published Deleted. 
     *
     * @param Published Value to match on Published.
     * @param Deleted Value to match on Deleted.
     */
    public long deleteByPublishedDeleted(Boolean published, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where published=? and deleted=? " +
                "");
            s.setBoolean(1,published);
            s.setBoolean(2,deleted);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on published archived. 
     *
     * @param published Value to match on Published.
     * @param archived Value to match on Archived.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByPublishedArchived(Boolean published, Boolean archived,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where published=? and archived=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setBoolean(1,published);
            s.setBoolean(2,archived);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Published Archived. 
     *
     * @param published Value to match on Published.
     * @param archived Value to match on Archived.
     */
    public long countByPublishedArchived(Boolean published, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where published=? and archived=? " +
                "");
            s.setBoolean(1,published);
            s.setBoolean(2,archived);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Published Archived. 
     *
     * @param Published Value to match on Published.
     * @param Archived Value to match on Archived.
     */
    public long deleteByPublishedArchived(Boolean published, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where published=? and archived=? " +
                "");
            s.setBoolean(1,published);
            s.setBoolean(2,archived);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on lastUpdate published. 
     *
     * @param lastUpdate Value to match on Last Update.
     * @param published Value to match on Published.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByLastUpdatePublished(Date lastUpdate, Boolean published,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where last_update=? and published=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            s.setBoolean(2,published);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Last Update Published. 
     *
     * @param lastUpdate Value to match on Last Update.
     * @param published Value to match on Published.
     */
    public long countByLastUpdatePublished(Date lastUpdate, Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where last_update=? and published=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            s.setBoolean(2,published);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Last Update Published. 
     *
     * @param LastUpdate Value to match on Last Update.
     * @param Published Value to match on Published.
     */
    public long deleteByLastUpdatePublished(Date lastUpdate, Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where last_update=? and published=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            s.setBoolean(2,published);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on lastUpdatePersonId published. 
     *
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     * @param published Value to match on Published.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByLastUpdatePersonIdPublished(Long lastUpdatePersonId, Boolean published,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where last_update_person_id=? and published=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,lastUpdatePersonId);
            s.setBoolean(2,published);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Last Update Person Id Published. 
     *
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     * @param published Value to match on Published.
     */
    public long countByLastUpdatePersonIdPublished(Long lastUpdatePersonId, Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where last_update_person_id=? and published=? " +
                "");
            s.setLong(1,lastUpdatePersonId);
            s.setBoolean(2,published);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Last Update Person Id Published. 
     *
     * @param LastUpdatePersonId Value to match on Last Update Person Id.
     * @param Published Value to match on Published.
     */
    public long deleteByLastUpdatePersonIdPublished(Long lastUpdatePersonId, Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where last_update_person_id=? and published=? " +
                "");
            s.setLong(1,lastUpdatePersonId);
            s.setBoolean(2,published);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on startDate published. 
     *
     * @param startDate Value to match on Start Date.
     * @param published Value to match on Published.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByStartDatePublished(Date startDate, Boolean published,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where start_date=? and published=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setTimestamp(1,new java.sql.Timestamp(startDate.getTime()));
            s.setBoolean(2,published);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Start Date Published. 
     *
     * @param startDate Value to match on Start Date.
     * @param published Value to match on Published.
     */
    public long countByStartDatePublished(Date startDate, Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where start_date=? and published=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(startDate.getTime()));
            s.setBoolean(2,published);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Start Date Published. 
     *
     * @param StartDate Value to match on Start Date.
     * @param Published Value to match on Published.
     */
    public long deleteByStartDatePublished(Date startDate, Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where start_date=? and published=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(startDate.getTime()));
            s.setBoolean(2,published);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on endDate published. 
     *
     * @param endDate Value to match on End Date.
     * @param published Value to match on Published.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByEndDatePublished(Date endDate, Boolean published,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where end_date=? and published=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setTimestamp(1,new java.sql.Timestamp(endDate.getTime()));
            s.setBoolean(2,published);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on End Date Published. 
     *
     * @param endDate Value to match on End Date.
     * @param published Value to match on Published.
     */
    public long countByEndDatePublished(Date endDate, Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where end_date=? and published=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(endDate.getTime()));
            s.setBoolean(2,published);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on End Date Published. 
     *
     * @param EndDate Value to match on End Date.
     * @param Published Value to match on Published.
     */
    public long deleteByEndDatePublished(Date endDate, Boolean published) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where end_date=? and published=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(endDate.getTime()));
            s.setBoolean(2,published);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on deleted archived. 
     *
     * @param deleted Value to match on Deleted.
     * @param archived Value to match on Archived.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByDeletedArchived(Boolean deleted, Boolean archived,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where deleted=? and archived=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setBoolean(1,deleted);
            s.setBoolean(2,archived);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Deleted Archived. 
     *
     * @param deleted Value to match on Deleted.
     * @param archived Value to match on Archived.
     */
    public long countByDeletedArchived(Boolean deleted, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where deleted=? and archived=? " +
                "");
            s.setBoolean(1,deleted);
            s.setBoolean(2,archived);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Deleted Archived. 
     *
     * @param Deleted Value to match on Deleted.
     * @param Archived Value to match on Archived.
     */
    public long deleteByDeletedArchived(Boolean deleted, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where deleted=? and archived=? " +
                "");
            s.setBoolean(1,deleted);
            s.setBoolean(2,archived);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on lastUpdate deleted. 
     *
     * @param lastUpdate Value to match on Last Update.
     * @param deleted Value to match on Deleted.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByLastUpdateDeleted(Date lastUpdate, Boolean deleted,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where last_update=? and deleted=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Last Update Deleted. 
     *
     * @param lastUpdate Value to match on Last Update.
     * @param deleted Value to match on Deleted.
     */
    public long countByLastUpdateDeleted(Date lastUpdate, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where last_update=? and deleted=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Last Update Deleted. 
     *
     * @param LastUpdate Value to match on Last Update.
     * @param Deleted Value to match on Deleted.
     */
    public long deleteByLastUpdateDeleted(Date lastUpdate, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where last_update=? and deleted=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            s.setBoolean(2,deleted);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on lastUpdatePersonId deleted. 
     *
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     * @param deleted Value to match on Deleted.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByLastUpdatePersonIdDeleted(Long lastUpdatePersonId, Boolean deleted,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where last_update_person_id=? and deleted=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,lastUpdatePersonId);
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Last Update Person Id Deleted. 
     *
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     * @param deleted Value to match on Deleted.
     */
    public long countByLastUpdatePersonIdDeleted(Long lastUpdatePersonId, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where last_update_person_id=? and deleted=? " +
                "");
            s.setLong(1,lastUpdatePersonId);
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Last Update Person Id Deleted. 
     *
     * @param LastUpdatePersonId Value to match on Last Update Person Id.
     * @param Deleted Value to match on Deleted.
     */
    public long deleteByLastUpdatePersonIdDeleted(Long lastUpdatePersonId, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where last_update_person_id=? and deleted=? " +
                "");
            s.setLong(1,lastUpdatePersonId);
            s.setBoolean(2,deleted);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on startDate deleted. 
     *
     * @param startDate Value to match on Start Date.
     * @param deleted Value to match on Deleted.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByStartDateDeleted(Date startDate, Boolean deleted,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where start_date=? and deleted=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setTimestamp(1,new java.sql.Timestamp(startDate.getTime()));
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Start Date Deleted. 
     *
     * @param startDate Value to match on Start Date.
     * @param deleted Value to match on Deleted.
     */
    public long countByStartDateDeleted(Date startDate, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where start_date=? and deleted=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(startDate.getTime()));
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Start Date Deleted. 
     *
     * @param StartDate Value to match on Start Date.
     * @param Deleted Value to match on Deleted.
     */
    public long deleteByStartDateDeleted(Date startDate, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where start_date=? and deleted=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(startDate.getTime()));
            s.setBoolean(2,deleted);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on endDate deleted. 
     *
     * @param endDate Value to match on End Date.
     * @param deleted Value to match on Deleted.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByEndDateDeleted(Date endDate, Boolean deleted,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where end_date=? and deleted=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setTimestamp(1,new java.sql.Timestamp(endDate.getTime()));
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on End Date Deleted. 
     *
     * @param endDate Value to match on End Date.
     * @param deleted Value to match on Deleted.
     */
    public long countByEndDateDeleted(Date endDate, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where end_date=? and deleted=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(endDate.getTime()));
            s.setBoolean(2,deleted);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on End Date Deleted. 
     *
     * @param EndDate Value to match on End Date.
     * @param Deleted Value to match on Deleted.
     */
    public long deleteByEndDateDeleted(Date endDate, Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where end_date=? and deleted=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(endDate.getTime()));
            s.setBoolean(2,deleted);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on lastUpdate archived. 
     *
     * @param lastUpdate Value to match on Last Update.
     * @param archived Value to match on Archived.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByLastUpdateArchived(Date lastUpdate, Boolean archived,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where last_update=? and archived=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            s.setBoolean(2,archived);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Last Update Archived. 
     *
     * @param lastUpdate Value to match on Last Update.
     * @param archived Value to match on Archived.
     */
    public long countByLastUpdateArchived(Date lastUpdate, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where last_update=? and archived=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            s.setBoolean(2,archived);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Last Update Archived. 
     *
     * @param LastUpdate Value to match on Last Update.
     * @param Archived Value to match on Archived.
     */
    public long deleteByLastUpdateArchived(Date lastUpdate, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where last_update=? and archived=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            s.setBoolean(2,archived);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on lastUpdatePersonId archived. 
     *
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     * @param archived Value to match on Archived.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByLastUpdatePersonIdArchived(Long lastUpdatePersonId, Boolean archived,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where last_update_person_id=? and archived=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,lastUpdatePersonId);
            s.setBoolean(2,archived);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Last Update Person Id Archived. 
     *
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     * @param archived Value to match on Archived.
     */
    public long countByLastUpdatePersonIdArchived(Long lastUpdatePersonId, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where last_update_person_id=? and archived=? " +
                "");
            s.setLong(1,lastUpdatePersonId);
            s.setBoolean(2,archived);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Last Update Person Id Archived. 
     *
     * @param LastUpdatePersonId Value to match on Last Update Person Id.
     * @param Archived Value to match on Archived.
     */
    public long deleteByLastUpdatePersonIdArchived(Long lastUpdatePersonId, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where last_update_person_id=? and archived=? " +
                "");
            s.setLong(1,lastUpdatePersonId);
            s.setBoolean(2,archived);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on startDate archived. 
     *
     * @param startDate Value to match on Start Date.
     * @param archived Value to match on Archived.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByStartDateArchived(Date startDate, Boolean archived,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where start_date=? and archived=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setTimestamp(1,new java.sql.Timestamp(startDate.getTime()));
            s.setBoolean(2,archived);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Start Date Archived. 
     *
     * @param startDate Value to match on Start Date.
     * @param archived Value to match on Archived.
     */
    public long countByStartDateArchived(Date startDate, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where start_date=? and archived=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(startDate.getTime()));
            s.setBoolean(2,archived);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Start Date Archived. 
     *
     * @param StartDate Value to match on Start Date.
     * @param Archived Value to match on Archived.
     */
    public long deleteByStartDateArchived(Date startDate, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where start_date=? and archived=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(startDate.getTime()));
            s.setBoolean(2,archived);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on endDate archived. 
     *
     * @param endDate Value to match on End Date.
     * @param archived Value to match on Archived.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByEndDateArchived(Date endDate, Boolean archived,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where end_date=? and archived=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setTimestamp(1,new java.sql.Timestamp(endDate.getTime()));
            s.setBoolean(2,archived);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on End Date Archived. 
     *
     * @param endDate Value to match on End Date.
     * @param archived Value to match on Archived.
     */
    public long countByEndDateArchived(Date endDate, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where end_date=? and archived=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(endDate.getTime()));
            s.setBoolean(2,archived);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on End Date Archived. 
     *
     * @param EndDate Value to match on End Date.
     * @param Archived Value to match on Archived.
     */
    public long deleteByEndDateArchived(Date endDate, Boolean archived) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where end_date=? and archived=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(endDate.getTime()));
            s.setBoolean(2,archived);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on lastUpdatePersonId lastUpdate. 
     *
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     * @param lastUpdate Value to match on Last Update.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByLastUpdatePersonIdLastUpdate(Long lastUpdatePersonId, Date lastUpdate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where last_update_person_id=? and last_update=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,lastUpdatePersonId);
            s.setTimestamp(2,new java.sql.Timestamp(lastUpdate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Last Update Person Id Last Update. 
     *
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     * @param lastUpdate Value to match on Last Update.
     */
    public long countByLastUpdatePersonIdLastUpdate(Long lastUpdatePersonId, Date lastUpdate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where last_update_person_id=? and last_update=? " +
                "");
            s.setLong(1,lastUpdatePersonId);
            s.setTimestamp(2,new java.sql.Timestamp(lastUpdate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Last Update Person Id Last Update. 
     *
     * @param LastUpdatePersonId Value to match on Last Update Person Id.
     * @param LastUpdate Value to match on Last Update.
     */
    public long deleteByLastUpdatePersonIdLastUpdate(Long lastUpdatePersonId, Date lastUpdate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where last_update_person_id=? and last_update=? " +
                "");
            s.setLong(1,lastUpdatePersonId);
            s.setTimestamp(2,new java.sql.Timestamp(lastUpdate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on lastUpdate startDate. 
     *
     * @param lastUpdate Value to match on Last Update.
     * @param startDate Value to match on Start Date.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByLastUpdateStartDate(Date lastUpdate, Date startDate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where last_update=? and start_date=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Last Update Start Date. 
     *
     * @param lastUpdate Value to match on Last Update.
     * @param startDate Value to match on Start Date.
     */
    public long countByLastUpdateStartDate(Date lastUpdate, Date startDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where last_update=? and start_date=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Last Update Start Date. 
     *
     * @param LastUpdate Value to match on Last Update.
     * @param StartDate Value to match on Start Date.
     */
    public long deleteByLastUpdateStartDate(Date lastUpdate, Date startDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where last_update=? and start_date=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on lastUpdate endDate. 
     *
     * @param lastUpdate Value to match on Last Update.
     * @param endDate Value to match on End Date.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByLastUpdateEndDate(Date lastUpdate, Date endDate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where last_update=? and end_date=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Last Update End Date. 
     *
     * @param lastUpdate Value to match on Last Update.
     * @param endDate Value to match on End Date.
     */
    public long countByLastUpdateEndDate(Date lastUpdate, Date endDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where last_update=? and end_date=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Last Update End Date. 
     *
     * @param LastUpdate Value to match on Last Update.
     * @param EndDate Value to match on End Date.
     */
    public long deleteByLastUpdateEndDate(Date lastUpdate, Date endDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where last_update=? and end_date=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(lastUpdate.getTime()));
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on lastUpdatePersonId startDate. 
     *
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     * @param startDate Value to match on Start Date.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByLastUpdatePersonIdStartDate(Long lastUpdatePersonId, Date startDate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where last_update_person_id=? and start_date=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,lastUpdatePersonId);
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Last Update Person Id Start Date. 
     *
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     * @param startDate Value to match on Start Date.
     */
    public long countByLastUpdatePersonIdStartDate(Long lastUpdatePersonId, Date startDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where last_update_person_id=? and start_date=? " +
                "");
            s.setLong(1,lastUpdatePersonId);
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Last Update Person Id Start Date. 
     *
     * @param LastUpdatePersonId Value to match on Last Update Person Id.
     * @param StartDate Value to match on Start Date.
     */
    public long deleteByLastUpdatePersonIdStartDate(Long lastUpdatePersonId, Date startDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where last_update_person_id=? and start_date=? " +
                "");
            s.setLong(1,lastUpdatePersonId);
            s.setTimestamp(2,new java.sql.Timestamp(startDate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on lastUpdatePersonId endDate. 
     *
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     * @param endDate Value to match on End Date.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByLastUpdatePersonIdEndDate(Long lastUpdatePersonId, Date endDate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where last_update_person_id=? and end_date=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setLong(1,lastUpdatePersonId);
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Last Update Person Id End Date. 
     *
     * @param lastUpdatePersonId Value to match on Last Update Person Id.
     * @param endDate Value to match on End Date.
     */
    public long countByLastUpdatePersonIdEndDate(Long lastUpdatePersonId, Date endDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where last_update_person_id=? and end_date=? " +
                "");
            s.setLong(1,lastUpdatePersonId);
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Last Update Person Id End Date. 
     *
     * @param LastUpdatePersonId Value to match on Last Update Person Id.
     * @param EndDate Value to match on End Date.
     */
    public long deleteByLastUpdatePersonIdEndDate(Long lastUpdatePersonId, Date endDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where last_update_person_id=? and end_date=? " +
                "");
            s.setLong(1,lastUpdatePersonId);
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on startDate endDate. 
     *
     * @param startDate Value to match on Start Date.
     * @param endDate Value to match on End Date.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByStartDateEndDate(Date startDate, Date endDate,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where start_date=? and end_date=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setTimestamp(1,new java.sql.Timestamp(startDate.getTime()));
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Start Date End Date. 
     *
     * @param startDate Value to match on Start Date.
     * @param endDate Value to match on End Date.
     */
    public long countByStartDateEndDate(Date startDate, Date endDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where start_date=? and end_date=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(startDate.getTime()));
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Start Date End Date. 
     *
     * @param StartDate Value to match on Start Date.
     * @param EndDate Value to match on End Date.
     */
    public long deleteByStartDateEndDate(Date startDate, Date endDate) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where start_date=? and end_date=? " +
                "");
            s.setTimestamp(1,new java.sql.Timestamp(startDate.getTime()));
            s.setTimestamp(2,new java.sql.Timestamp(endDate.getTime()));
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on name. 
     *
     * @param name Value to match on Name.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByName(String name,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where name=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setString(1,name);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Name. 
     *
     * @param name Value to match on Name.
     */
    public long countByName(String name) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where name=? " +
                "");
            s.setString(1,name);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Name. 
     *
     * @param Name Value to match on Name.
     */
    public long deleteByName(String name) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where name=? " +
                "");
            s.setString(1,name);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Retrieve a set from the Newsletter data source
     * matching on deleted. 
     *
     * @param deleted Value to match on Deleted.
     * @param index Search results should start from this item.
     * @param limit Search results should return at most this many items.
     */
    public List<Newsletter> getByDeleted(Boolean deleted,  long index, long limit) throws IOException {
        List<Newsletter> list=new ArrayList<Newsletter>();
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        Newsletter item=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select id, publication_id, name, status, version, published, deleted, archived, last_update, last_update_person_id, start_date, end_date "+
                "from newsletter " +
                "where deleted=? " +
                "order by start_date " +
                "limit "+index+","+limit
                );
            s.setBoolean(1,deleted);
            results=s.executeQuery();
            while(results.next()) {
                item=new Newsletter();
                item.setId(results.getLong(1));
                item.setPublicationId(results.getLong(2));
                item.setName(results.getString(3));
                item.setStatus(results.getString(4));
                item.setVersion(results.getLong(5));
                item.setPublished(results.getBoolean(6));
                item.setDeleted(results.getBoolean(7));
                item.setArchived(results.getBoolean(8));
                item.setLastUpdate(results.getDate(9));
                item.setLastUpdatePersonId(results.getLong(10));
                item.setStartDate(results.getDate(11));
                item.setEndDate(results.getDate(12));
                list.add(item);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return list;
    }

    /**
     * Count number of items in the <i>Newsletter</i> data source
     * matching on Deleted. 
     *
     * @param deleted Value to match on Deleted.
     */
    public long countByDeleted(Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        ResultSet results=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "select count(*)"+
                "from newsletter " +
                "where deleted=? " +
                "");
            s.setBoolean(1,deleted);
            results=s.executeQuery();
            if(results.next()) {
                total=results.getLong(1);
            }
            results.close();
            results=null;
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(results!=null) { try { results.close(); } catch(Exception f){} }
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }

    /**
     * Delete of item(s) in the Newsletter data source
     * matching on Deleted. 
     *
     * @param Deleted Value to match on Deleted.
     */
    public long deleteByDeleted(Boolean deleted) throws IOException {
        long total=0;
        Connection c=null;
        PreparedStatement s=null;
        try {
            c=dataSource.getConnection();
            s=c.prepareStatement(
                "delete from newsletter " +
                "where deleted=? " +
                "");
            s.setBoolean(1,deleted);
            s.executeUpdate();
            s.close();
            s=null;
            c.close();
            c=null;
        } catch(SQLException e) {
            if(s!=null) { try { s.close(); } catch(Exception f){} }
            if(c!=null) { try { c.close(); } catch(Exception f){} }
            throw new IOException(e.toString());
        }

        return total;
    }


}
